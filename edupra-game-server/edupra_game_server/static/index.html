<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Security-Policy"
        content="default-src *; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'">
    <meta charset="UTF-8">
    <title>Backgammon GUI</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ecf0f1;
        }

        h1 {
            text-align: center;
            margin: 20px 0;
            font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 3px;
        }

        #game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            padding: 0 20px;
        }

        #left-panel, #right-panel {
            background: rgba(44, 62, 80, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 250px;
            height: 600px;
        }

        #history {
            width: 100%;
            height: 100%;
            background: #34495e;
            color: #ecf0f1;
            border: none;
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            box-sizing: border-box;
        }

        #hint {
            height: 100%;
            overflow-y: auto;
        }

        #hint h3 {
            margin-top: 0;
            color: #3498db;
        }

        #hint button {
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            text-align: left;
        }

        #hint button:hover:enabled {
            background: #2980b9;
            transform: translateX(5px);
        }

        #canvas-container {
            text-align: center;
        }

        #boardCanvas {
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }

        #controls {
            margin-top: 20px;
            background: rgba(44, 62, 80, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #controls p {
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
        }

        #controls label {
            font-size: 16px;
            margin-right: 10px;
        }

        #action-choice {
            padding: 8px 12px;
            font-size: 16px;
            border: 2px solid #3498db;
            border-radius: 5px;
            background: #34495e;
            color: #ecf0f1;
            margin-right: 10px;
        }

        #button-execute {
            padding: 10px 30px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #button-execute:hover:enabled {
            background: #229954;
            transform: scale(1.05);
        }

        #button-execute:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        li {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>

<body onload="init()">
    <h1>ðŸŽ² BACKGAMMON ðŸŽ²</h1>

    <div id="game-container">
        <div id="left-panel">
            <textarea id='history' readonly disabled></textarea>
        </div>

        <div id='canvas-container'>
            <canvas id="boardCanvas" width="700" height="600"></canvas>

            <div id="controls">
                <p>Current Player: <span id="current-player">WHITE</span></p>
                <label for="action-choice">Choose your move:</label>
                <input list="actions" id="action-choice" name="action-choice" value="" size="35" maxlength="35" oninput="check_input()"/>
                <datalist id="actions">
                    <option value="start">
                </datalist>
                <button onclick="execute_action()" id='button-execute'>MAKE MOVE</button>
            </div>
        </div>

        <div id="right-panel">
            <div id='hint'>
                <h3>Available Moves</h3>
            </div>
        </div>
    </div>
</body>

<script>
    // Canvas setup
    let c = document.getElementById("boardCanvas");
    let ctx = c.getContext("2d");
    let width = c.width;
    let height = c.height;
    
    // Board dimensions
    const BORDER = 50;
    const HALF_BOARD_WIDTH = (width - 4 * BORDER) / 2;
    const HALF_BOARD_HEIGHT = height - 2 * BORDER;
    const HALF_BOARD_RIGHT_START = 3 * BORDER + HALF_BOARD_WIDTH;
    
    // Points dimensions
    const POINT_WIDTH = HALF_BOARD_WIDTH / 6;
    const POINT_HEIGHT = height * 4.5 / 10;
    
    // Colors
    const COLORS = {
        DARK_TRIANGLE: '#8B4513',
        LIGHT_TRIANGLE: '#DEB887',
        BOARD: '#654321',
        BORDER: '#D4AF37',
        INNER_BOARD: '#2C1810',
        BOARD_GRADIENT_TOP: '#3d2817',
        BOARD_GRADIENT_BOTTOM: '#1f120a',
        BORDER_INNER: '#8B6914',
        SHADOW: 'rgba(0, 0, 0, 0.5)',
        CHECKER_SHADOW: 'rgba(0, 0, 0, 0.4)',
        BORDER_SHADOW: 'rgba(212, 175, 55, 0.5)',
        TRIANGLE_STROKE: 'rgba(0, 0, 0, 0.3)'
    };
    
    // Checker dimensions
    const CHECKER_RADIUS = POINT_WIDTH / 2;
    const MAX_VISIBLE_CHECKERS = 5;
    
    // Font settings
    ctx.font = "25px Arial";


    function init() {
        draw();
        document.getElementById("action-choice").value = '';
        document.getElementById("history").value = 'LOG\n';
        
        resetHint();
        addActionButton('start');
        document.getElementById("button-execute").disabled = true;
    }
    
    function resetHint() {
        document.getElementById("hint").innerHTML = '<h3>Available Moves</h3>';
    }
    
    function addActionButton(action) {
        const node = document.createElement("li");
        const buttonNode = document.createElement('button');
        buttonNode.innerHTML = action;
        buttonNode.onclick = function() {
            document.getElementById("action-choice").value = action;
            execute_action();
        };
        
        // Animation
        buttonNode.style.opacity = '0';
        buttonNode.style.animation = 'fadeIn 0.3s ease forwards';
        buttonNode.style.animationDelay = (document.getElementById("hint").children.length * 0.05) + 's';
        
        node.appendChild(buttonNode);
        document.getElementById("hint").appendChild(node);
    }

    function check_input() {
        const val = document.getElementById("action-choice").value;
        const actions = document.getElementById("actions").childNodes;
        const isValid = Array.from(actions).some(action => action.value === val);
        document.getElementById("button-execute").disabled = !isValid;
    }
    function draw() {
        drawBackground();
        drawBoardHalves();
        drawBorders();
        drawAllPoints();
    }
    
    function drawBackground() {
        ctx.fillStyle = COLORS.BOARD;
        ctx.fillRect(0, 0, width, height);
    }
    
    function drawBoardHalves() {
        const boardGradient = ctx.createLinearGradient(0, BORDER, 0, height - BORDER);
        boardGradient.addColorStop(0, COLORS.BOARD_GRADIENT_TOP);
        boardGradient.addColorStop(0.5, COLORS.INNER_BOARD);
        boardGradient.addColorStop(1, COLORS.BOARD_GRADIENT_BOTTOM);
        
        ctx.save();
        ctx.shadowColor = COLORS.SHADOW;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        
        ctx.fillStyle = boardGradient;
        ctx.fillRect(BORDER, BORDER, HALF_BOARD_WIDTH, HALF_BOARD_HEIGHT);
        ctx.fillRect(HALF_BOARD_RIGHT_START, BORDER, HALF_BOARD_WIDTH, HALF_BOARD_HEIGHT);
        
        ctx.restore();
    }
    
    function drawBorders() {
        // Center line
        ctx.save();
        ctx.strokeStyle = COLORS.BORDER;
        ctx.lineWidth = 6;
        ctx.shadowColor = COLORS.BORDER_SHADOW;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(width / 2, BORDER);
        ctx.lineTo(width / 2, height - BORDER);
        ctx.stroke();
        ctx.restore();
        
        // Double border frames
        ctx.save();
        ctx.strokeStyle = COLORS.BORDER;
        ctx.lineWidth = 6;
        ctx.shadowColor = COLORS.BORDER_SHADOW;
        ctx.shadowBlur = 15;
        
        // Outer borders
        ctx.strokeRect(BORDER - 3, BORDER - 3, HALF_BOARD_WIDTH + 6, HALF_BOARD_HEIGHT + 6);
        ctx.strokeRect(HALF_BOARD_RIGHT_START - 3, BORDER - 3, HALF_BOARD_WIDTH + 6, HALF_BOARD_HEIGHT + 6);
        
        // Inner borders
        ctx.lineWidth = 2;
        ctx.strokeStyle = COLORS.BORDER_INNER;
        ctx.strokeRect(BORDER + 2, BORDER + 2, HALF_BOARD_WIDTH - 4, HALF_BOARD_HEIGHT - 4);
        ctx.strokeRect(HALF_BOARD_RIGHT_START + 2, BORDER + 2, HALF_BOARD_WIDTH - 4, HALF_BOARD_HEIGHT - 4);
        
        ctx.restore();
    }

    function drawAllPoints() {
        // Top left (12-17)
        for (let i = 0; i < 6; i++) {
            drawPoint(BORDER + i * POINT_WIDTH, BORDER, POINT_HEIGHT, i % 2 === 0, true);
            drawPointNumber(12 + i, BORDER + i * POINT_WIDTH + 5, BORDER - 15);
        }
        
        // Top right (18-23)
        for (let i = 0; i < 6; i++) {
            drawPoint(HALF_BOARD_RIGHT_START + i * POINT_WIDTH, BORDER, POINT_HEIGHT, i % 2 === 0, true);
            drawPointNumber(18 + i, HALF_BOARD_RIGHT_START + i * POINT_WIDTH + 5, BORDER - 15);
        }
        
        // Bottom left (11-6)
        for (let i = 0; i < 6; i++) {
            drawPoint(BORDER + i * POINT_WIDTH, height - BORDER, height - POINT_HEIGHT, i % 2 !== 0, false);
            const number = 11 - i;
            const xOffset = number < 10 ? 15 : 5;
            drawPointNumber(number, BORDER + i * POINT_WIDTH + xOffset, height - BORDER + 35);
        }
        
        // Bottom right (5-0)
        for (let i = 0; i < 6; i++) {
            drawPoint(HALF_BOARD_RIGHT_START + i * POINT_WIDTH, height - BORDER, height - POINT_HEIGHT, i % 2 !== 0, false);
            drawPointNumber(5 - i, HALF_BOARD_RIGHT_START + i * POINT_WIDTH + 15, height - BORDER + 35);
        }
    }
    
    function drawPoint(x, y1, y2, isDark, isTop) {
        ctx.save();
        
        const gradient = ctx.createLinearGradient(x + POINT_WIDTH / 2, y1, x + POINT_WIDTH / 2, y2);
        if (isDark) {
            gradient.addColorStop(0, COLORS.DARK_TRIANGLE);
            gradient.addColorStop(1, '#6B3410');
        } else {
            gradient.addColorStop(0, COLORS.LIGHT_TRIANGLE);
            gradient.addColorStop(1, '#C9A876');
        }
        
        ctx.beginPath();
        ctx.moveTo(x, y1);
        ctx.lineTo(x + POINT_WIDTH / 2, y2);
        ctx.lineTo(x + POINT_WIDTH, y1);
        ctx.closePath();
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        ctx.strokeStyle = COLORS.TRIANGLE_STROKE;
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.restore();
    }
    
    function drawPointNumber(number, x, y) {
        ctx.save();
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = 'black';
        ctx.fillText(number, x, y);
        ctx.restore();
    }

    function draw_board(board, bar, off) {
        draw();
        if (board != null) {
            board.forEach((data, point) => {
                const checkers = data[0];
                const player = data[1];
                
                if (player != null) {
                    const isBlack = player === 1;
                    drawCheckersAtPoint(point, checkers, isBlack);
                }
            });
        }
        draw_bar_off(bar, off);
    }
    
    function drawCheckersAtPoint(point, checkers, isBlack) {
        const positions = getPointPositions(point);
        if (!positions) return;
        
        for (let i = 0; i < Math.min(checkers, MAX_VISIBLE_CHECKERS); i++) {
            const x = positions.x;
            const y = positions.getY(i);
            
            drawChecker(x, y, isBlack);
            
            if (i === MAX_VISIBLE_CHECKERS - 1 && checkers > MAX_VISIBLE_CHECKERS) {
                drawCheckerCount(x, y, checkers, isBlack);
                break;
            }
        }
    }
    
    function getPointPositions(point) {
        // Bottom right (0-5)
        if (point >= 0 && point < 6) {
            const x = HALF_BOARD_RIGHT_START + POINT_WIDTH * (5 - point) + CHECKER_RADIUS;
            return {
                x: x,
                getY: (i) => height - BORDER - CHECKER_RADIUS - 2 * i * CHECKER_RADIUS
            };
        }
        // Bottom left (6-11)
        else if (point >= 6 && point < 12) {
            const x = BORDER + POINT_WIDTH * (11 - point) + CHECKER_RADIUS;
            return {
                x: x,
                getY: (i) => height - BORDER - CHECKER_RADIUS - 2 * i * CHECKER_RADIUS
            };
        }
        // Top left (12-17)
        else if (point >= 12 && point < 18) {
            const x = BORDER + POINT_WIDTH * (point - 12) + CHECKER_RADIUS;
            return {
                x: x,
                getY: (i) => BORDER + CHECKER_RADIUS + 2 * i * CHECKER_RADIUS
            };
        }
        // Top right (18-23)
        else if (point >= 18 && point < 24) {
            const x = HALF_BOARD_RIGHT_START + POINT_WIDTH * (point - 18) + CHECKER_RADIUS;
            return {
                x: x,
                getY: (i) => BORDER + CHECKER_RADIUS + 2 * i * CHECKER_RADIUS
            };
        }
        return null;
    }
    
    function drawChecker(x, y, isBlack) {
        ctx.save();
        
        // Shadow
        ctx.shadowColor = COLORS.CHECKER_SHADOW;
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        // Main checker
        ctx.beginPath();
        ctx.arc(x, y, CHECKER_RADIUS, 0, 2 * Math.PI);
        
        // Gradient
        const gradient = ctx.createRadialGradient(
            x - CHECKER_RADIUS/3, y - CHECKER_RADIUS/3, 0,
            x, y, CHECKER_RADIUS
        );
        
        if (isBlack) {
            gradient.addColorStop(0, '#404040');
            gradient.addColorStop(0.7, '#202020');
            gradient.addColorStop(1, '#000000');
        } else {
            gradient.addColorStop(0, '#FFFFFF');
            gradient.addColorStop(0.7, '#F0F0F0');
            gradient.addColorStop(1, '#D0D0D0');
        }
        
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.strokeStyle = isBlack ? 'white' : 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Highlight
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(x - CHECKER_RADIUS/3, y - CHECKER_RADIUS/3, CHECKER_RADIUS/3, 0, 2 * Math.PI);
        
        const highlightGradient = ctx.createRadialGradient(
            x - CHECKER_RADIUS/3, y - CHECKER_RADIUS/3, 0,
            x - CHECKER_RADIUS/3, y - CHECKER_RADIUS/3, CHECKER_RADIUS/3
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
        ctx.fillStyle = highlightGradient;
        ctx.fill();
        
        ctx.restore();
    }
    
    function drawCheckerCount(x, y, count, isBlack) {
        ctx.save();
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = isBlack ? 'white' : 'black';
        ctx.font = "bold 20px Arial";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(count, x, y);
        ctx.font = "25px Arial";
        ctx.restore();
    }

    function draw_bar_off(bar, off) {
        const [barWhite, barBlack] = bar;
        const [offWhite, offBlack] = off;
        
        // Draw bar checkers
        drawBarCheckers(barWhite, width / 2, BORDER, false);
        drawBarCheckers(barBlack, width / 2, height - BORDER, true);
        
        // Draw off checkers
        drawOffCheckers(offBlack, width - BORDER + CHECKER_RADIUS, BORDER, true);
        drawOffCheckers(offWhite, width - BORDER + CHECKER_RADIUS, height - BORDER, false);
    }
    
    function drawBarCheckers(count, x, startY, isBlack) {
        const maxVisible = 4;
        for (let i = 0; i < Math.min(count, maxVisible); i++) {
            const y = isBlack ? 
                startY - CHECKER_RADIUS - 2 * i * CHECKER_RADIUS :
                startY + CHECKER_RADIUS + 2 * i * CHECKER_RADIUS;
            
            drawChecker(x, y, isBlack);
            
            if (i === maxVisible - 1 && count > maxVisible) {
                drawCheckerCount(x, y, count, isBlack);
                break;
            }
        }
    }
    
    function drawOffCheckers(count, x, startY, isBlack) {
        const maxVisible = 4;
        for (let i = 0; i < Math.min(count, maxVisible); i++) {
            const y = isBlack ?
                startY + CHECKER_RADIUS + 2 * i * CHECKER_RADIUS :
                startY - CHECKER_RADIUS - 2 * i * CHECKER_RADIUS;
            
            drawChecker(x, y, isBlack);
            
            if (i === maxVisible - 1 && count > maxVisible) {
                drawCheckerCount(x, y, count, isBlack);
                break;
            }
        }
    }

    function execute_action() {
        document.getElementById("button-execute").disabled = true;
        let xhr = new XMLHttpRequest();
        let url = location.origin;
        xhr.open("POST", url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let json_data = JSON.parse(xhr.responseText);
                update(json_data)
            }
        };
        let command = document.getElementById('action-choice').value
        let data = {'command':command}
        xhr.send(JSON.stringify(data));
    }

    function update(data) {
        console.log(data['message']);
        
        const { actions, state } = data;
        const [board, bar, off] = state;
        
        // Update history
        const historyElement = document.getElementById("history");
        historyElement.value += '\n' + data['message'];
        historyElement.scrollTop = historyElement.scrollHeight;
        
        // Clear input
        document.getElementById("action-choice").value = '';
        
        // Update available actions
        updateActions(actions);
        
        // Update board
        draw_board(board, bar, off);
    }
    
    function updateActions(actions) {
        let options = '';
        resetHint();
        
        actions.forEach(action => {
            if (Array.isArray(action)) {
                const moves = formatMoves(action);
                options += `<option value="${moves}" />`;
                addActionButton(moves);
            } else {
                options += `<option value="${action}" />`;
                addActionButton(action);
            }
        });
        
        document.getElementById('actions').innerHTML = options;
    }
    
    function formatMoves(action) {
        const moves = action.map(move => `(${move.join('/')})`).join(',');
        return `move ${moves}`;
    }


    // Event listeners
    document.getElementById("action-choice").addEventListener("keyup", function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            document.getElementById("button-execute").click();
        }
    });
</script>


</html>
